<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>PDF Viewer</title>
<!-- Minimal styling -->
<style>
  :root{
    --bg:#0f1724;
    --panel:#0b1220;
    --accent:#06b6d4;
    --muted:#94a3b8;
    --glass: rgba(255,255,255,0.04);
    --danger: #ef4444;
  }
  html,body{height:100%;margin:0;font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  body{background:linear-gradient(180deg,#071024 0%, #07142a 100%);color:#e6eef6;display:flex;flex-direction:column;gap:12px;padding:14px;box-sizing:border-box;}
  header{display:flex;align-items:center;gap:12px;}
  h1{font-size:16px;margin:0;font-weight:600}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  .panel{background:var(--panel);border-radius:12px;padding:12px;box-shadow: 0 6px 18px rgba(2,6,23,0.6);}
  .layout{display:grid;grid-template-columns: 1fr;gap:12px;align-items:start;}
  /* PDF viewer */
  .pdf-area{min-height:420px;display:flex;flex-direction:column;gap:8px}
  #pdfCanvas{width:100%;border-radius:8px;background:var(--glass);display:block;max-height:70vh;object-fit:contain}
  .pdf-toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button, .btn {
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
    border:1px solid rgba(255,255,255,0.06);
    color:inherit;
    padding:8px 12px;border-radius:8px;cursor:pointer;font-weight:600;
    backdrop-filter: blur(4px);
  }
  button.small{padding:6px 8px;font-size:14px;border-radius:6px}
  input[type=range]{width:140px}
  .status{font-size:13px;color:var(--muted)}
  /* Big floating X save button at left bottom */
  #saveX{
    position:fixed;
    left:12px;
    bottom:12px;
    z-index:9999;
    width:56px;height:56px;border-radius:50%;
    display:flex;align-items:center;justify-content:center;
    background: linear-gradient(180deg,var(--danger),#b91c1c);
    color:white;font-size:22px;font-weight:700;
    box-shadow:0 6px 24px rgba(185,28,28,0.35);
    border: 2px solid rgba(255,255,255,0.06);
    -webkit-tap-highlight-color: transparent;
  }
  /* small badges */
  .badge{background:rgba(255,255,255,0.03);padding:6px 8px;border-radius:999px;font-size:13px;border:1px solid rgba(255,255,255,0.03)}
  .hint{font-size:13px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <h1>PDF Viewer</h1>
</header>
<div class="layout">
  <!-- Left: PDF -->
  <div class="left panel pdf-area">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div style="display:flex;gap:8px;align-items:center;">
        <label class="btn small" for="pdfFile">Load PDF</label>
        <input id="pdfFile" type="file" accept="application/pdf" style="display:none" />
        <div class="hint">or paste a URL below</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="prevPage" class="small">◀ Prev</button>
        <button id="nextPage" class="small">Next ▶</button>
        <div class="badge" id="pageInfo">— / —</div>
      </div>
    </div>
    <div class="pdf-toolbar" style="justify-content:space-between;">
      <div style="display:flex;gap:8px;align-items:center;">
        <input id="pdfUrl" type="url" placeholder="https://example.com/file.pdf" style="width:260px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);background:transparent;color:inherit" />
        <button id="loadUrl">Load URL</button>
        <label class="hint">Zoom</label>
        <input id="zoom" type="range" min="0.25" max="2.5" step="0.05" value="1">
        <div class="hint" id="zoomVal">100%</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button id="downloadPdf">Download PDF</button>
        <div class="status" id="pdfStatus">Tap X to start recording</div>
      </div>
    </div>
    <canvas id="pdfCanvas"></canvas>
  </div>
</div>
<!-- Floating X on left-bottom that saves recording when pressed -->
<button id="saveX" title="Start/Stop recording">✕</button>
<!-- Minimal scripts: PDF.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.min.js"></script>
<script>
/* =========================
   PDF Reader (PDF.js)
   ========================= */
const pdfFileInput = document.getElementById('pdfFile');
const pdfUrlInput  = document.getElementById('pdfUrl');
const loadUrlBtn   = document.getElementById('loadUrl');
const downloadPdfBtn = document.getElementById('downloadPdf');
const pdfCanvas = document.getElementById('pdfCanvas');
const pdfCtx = pdfCanvas.getContext('2d');
const prevPageBtn = document.getElementById('prevPage');
const nextPageBtn = document.getElementById('nextPage');
const pageInfo = document.getElementById('pageInfo');
const pdfStatus = document.getElementById('pdfStatus');
const zoomRange = document.getElementById('zoom');
const zoomVal = document.getElementById('zoomVal');
let pdfDoc = null;
let currentPage = 1;
let pdfScale = parseFloat(zoomRange.value);
let loadedPdfArrayBuffer = null;

// Ensure PDF.js is loaded before using it
if (typeof pdfjsLib === 'undefined') {
  pdfStatus.textContent = 'PDF.js failed to load';
  console.error('PDF.js not loaded');
} else {
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.14.305/pdf.worker.min.js';
}

function renderPage(num) {
  if (!pdfDoc) return;
  pdfDoc.getPage(num).then(page => {
    const viewport = page.getViewport({ scale: pdfScale });
    const dpr = window.devicePixelRatio || 1;
    
    // Set canvas dimensions with device pixel ratio
    pdfCanvas.width = Math.min(viewport.width * dpr, 4096);
    pdfCanvas.height = viewport.height * dpr;
    pdfCanvas.style.width = Math.min(viewport.width, window.innerWidth * 0.92) + 'px';
    pdfCanvas.style.height = viewport.height + 'px';
    
    const renderContext = {
      canvasContext: pdfCtx,
      viewport: page.getViewport({ scale: pdfScale * dpr })
    };
    
    pdfCtx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
    page.render(renderContext).promise.then(() => {
      pageInfo.textContent = num + ' / ' + pdfDoc.numPages;
      pdfStatus.textContent = 'Rendered page ' + num;
    }).catch(err => {
      pdfStatus.textContent = 'Render error: ' + err.message;
    });
  }).catch(err => {
    pdfStatus.textContent = 'Page load error: ' + err.message;
  });
}

function loadPdfFromArrayBuffer(ab, name) {
  loadedPdfArrayBuffer = ab;
  pdfjsLib.getDocument({ data: ab }).promise.then(doc => {
    pdfDoc = doc;
    currentPage = 1;
    renderPage(currentPage);
    pdfStatus.textContent = 'Loaded ' + (name || 'PDF') + ' (' + doc.numPages + ' pages)';
  }).catch(err => {
    pdfStatus.textContent = 'PDF load error: ' + (err.message || err);
  });
}

pdfFileInput.addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;
  pdfStatus.textContent = 'Loading ' + f.name;
  try {
    const ab = await f.arrayBuffer();
    loadPdfFromArrayBuffer(ab, f.name);
  } catch (err) {
    pdfStatus.textContent = 'File read error: ' + err.message;
  }
});

loadUrlBtn.addEventListener('click', async () => {
  const url = pdfUrlInput.value.trim();
  if (!url) { 
    pdfStatus.textContent = 'Enter a valid PDF URL'; 
    return; 
  }
  pdfStatus.textContent = 'Fetching URL...';
  try {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const ab = await resp.arrayBuffer();
    loadPdfFromArrayBuffer(ab, url);
  } catch (err) {
    pdfStatus.textContent = 'Fetch error: ' + err.message;
  }
});

prevPageBtn.addEventListener('click', () => {
  if (!pdfDoc || currentPage <= 1) return;
  currentPage--;
  renderPage(currentPage);
});

nextPageBtn.addEventListener('click', () => {
  if (!pdfDoc || currentPage >= pdfDoc.numPages) return;
  currentPage++;
  renderPage(currentPage);
});

zoomRange.addEventListener('input', () => {
  pdfScale = parseFloat(zoomRange.value);
  zoomVal.textContent = Math.round(pdfScale * 100) + '%';
  if (pdfDoc) renderPage(currentPage);
});

downloadPdfBtn.addEventListener('click', () => {
  if (!loadedPdfArrayBuffer) {
    pdfStatus.textContent = 'No PDF to download';
    return;
  }
  const blob = new Blob([loadedPdfArrayBuffer], { type: 'application/pdf' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'download.pdf';
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
});

/* =========================
   Camera Recorder
   ========================= */
const saveX = document.getElementById('saveX');
let stream = null;
let mediaRecorder = null;
let activeRecordingBlobs = [];
let lastRecordingBlob = null;
let lastRecordingName = null;
let mimeType = 'video/webm';

// Check supported MIME types for recording
const checkSupportedMimeTypes = () => {
  const supportedTypes = ['video/mp4', 'video/webm'];
  for (const type of supportedTypes) {
    if (MediaRecorder.isTypeSupported(type)) {
      mimeType = type;
      return;
    }
  }
  mimeType = 'video/webm'; // fallback
};

// Initialize camera and start recording
async function initHiddenRecording() {
  try {
    checkSupportedMimeTypes();
    
    const constraints = {
      audio: true,
      video: { facingMode: "user" }
    };
    
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    mediaRecorder = new MediaRecorder(stream, { mimeType });
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) {
        activeRecordingBlobs.push(e.data);
      }
    };
    
    mediaRecorder.onstart = () => {
      pdfStatus.textContent = 'Recording... Tap X to stop';
    };
    
    mediaRecorder.onstop = () => {
      if (activeRecordingBlobs.length) {
        lastRecordingBlob = new Blob(activeRecordingBlobs, { type: mimeType });
        
        // Format timestamp as YYYY-MM-DD-HH-MM-SS
        const date = new Date();
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        const timestamp = `${year}-${month}-${day}-${hours}-${minutes}-${seconds}`;
        lastRecordingName = `${timestamp}.mp4`; // Always use .mp4 extension for filename
        
        pdfStatus.textContent = 'Recording saved. Tap X to download';
      }
      activeRecordingBlobs = [];
    };
    
    mediaRecorder.start(1000);
  } catch (err) {
    pdfStatus.textContent = 'Camera error: ' + err.message;
    console.error('Camera error:', err);
  }
}

// Save recording when the 'X' button is pressed
saveX.addEventListener('click', () => {
  if (!mediaRecorder || mediaRecorder.state === 'inactive') {
    // Start recording when button is clicked (proper user gesture)
    initHiddenRecording();
  } else if (mediaRecorder.state === 'recording') {
    // Stop recording
    mediaRecorder.stop();
  } else if (lastRecordingBlob) {
    // Download saved recording
    triggerDownloadBlob(lastRecordingBlob, lastRecordingName);
  }
});

function triggerDownloadBlob(blob, filename) {
  if (!blob) return;
  
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
}

// Clean up when leaving the page
window.addEventListener('beforeunload', () => {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
  if (stream) {
    stream.getTracks().forEach(track => track.stop());
  }
});
</script>
</body>
</html>
